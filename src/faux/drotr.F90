!>@brief \b DROTR premultiplies the rows (p,q) of G by W.
PURE SUBROUTINE DROTR(M, N, G, LDG, P, Q, W, INFO)
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
  IMPLICIT NONE
  INTEGER, PARAMETER :: K = REAL64
  INTEGER, INTENT(IN) :: M, N, LDG, P, Q
  REAL(KIND=K), INTENT(INOUT) :: G(LDG,N)
  REAL(KIND=K), INTENT(IN) :: W(2,2)
  INTEGER, INTENT(INOUT) :: INFO
  IF (MOD(N, 8) .EQ. 0) THEN
     CALL DROTR8(M, N, G, LDG, P, Q, W, INFO)
  ELSE IF (MOD(N, 4) .EQ. 0) THEN
     CALL DROTR4(M, N, G, LDG, P, Q, W, INFO)
  ELSE IF (MOD(N, 2) .EQ. 0) THEN
     CALL DROTR2(M, N, G, LDG, P, Q, W, INFO)
  ELSE ! the general case
     CALL DROTR1(M, N, G, LDG, P, Q, W, INFO)
  END IF
CONTAINS
  PURE SUBROUTINE DROTR1(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    REAL(KIND=K), INTENT(INOUT) :: G(LDG,N)
    REAL(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 1
#include "grotr.F90"
  END SUBROUTINE DROTR1
  PURE SUBROUTINE DROTR2(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    REAL(KIND=K), INTENT(INOUT) :: G(LDG,N)
    REAL(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 2
#include "grotr.F90"
  END SUBROUTINE DROTR2
  PURE SUBROUTINE DROTR4(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    REAL(KIND=K), INTENT(INOUT) :: G(LDG,N)
    REAL(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 4
#include "grotr.F90"
  END SUBROUTINE DROTR4
  PURE SUBROUTINE DROTR8(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    REAL(KIND=K), INTENT(INOUT) :: G(LDG,N)
    REAL(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 8
#include "grotr.F90"
  END SUBROUTINE DROTR8
END SUBROUTINE DROTR
