!>@brief \b CROTR premultiplies the rows (p,q) of G by W.
PURE SUBROUTINE CROTR(M, N, G, LDG, P, Q, W, INFO)
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
  IMPLICIT NONE
#ifdef CR_MATH
  INTERFACE
     PURE FUNCTION CR_HYPOT(X, Y) BIND(C,NAME='cr_hypotf')
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_float
       REAL(KIND=c_float), INTENT(IN), VALUE :: X, Y
       REAL(KIND=c_float) :: CR_HYPOT
     END FUNCTION CR_HYPOT
  END INTERFACE
#else
#define CR_HYPOT HYPOT
#endif
  INTERFACE
     PURE FUNCTION CMUL(A, B)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
       IMPLICIT NONE
       COMPLEX(KIND=REAL32), INTENT(IN) :: A, B
       COMPLEX(KIND=REAL32) :: CMUL
     END FUNCTION CMUL
  END INTERFACE
#define MUL CMUL
  INTERFACE
     PURE FUNCTION CFMA(A, B, C)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
       IMPLICIT NONE
       COMPLEX(KIND=REAL32), INTENT(IN) :: A, B, C
       COMPLEX(KIND=REAL32) :: CFMA
     END FUNCTION CFMA
  END INTERFACE
#define FMA CFMA
  INTEGER, PARAMETER :: K = REAL32
  INTEGER, INTENT(IN) :: M, N, LDG, P, Q
  COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
  COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
  INTEGER, INTENT(INOUT) :: INFO
  IF (MOD(N, 8) .EQ. 0) THEN
     CALL CROTR8(M, N, G, LDG, P, Q, W, INFO)
  ELSE IF (MOD(N, 4) .EQ. 0) THEN
     CALL CROTR4(M, N, G, LDG, P, Q, W, INFO)
  ELSE IF (MOD(N, 2) .EQ. 0) THEN
     CALL CROTR2(M, N, G, LDG, P, Q, W, INFO)
  ELSE ! the general case
     CALL CROTR1(M, N, G, LDG, P, Q, W, INFO)
  END IF
CONTAINS
  PURE SUBROUTINE CROTR1(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL32
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 1
#include "hrotr.F90"
  END SUBROUTINE CROTR1
  PURE SUBROUTINE CROTR2(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL32
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 2
#include "hrotr.F90"
  END SUBROUTINE CROTR2
  PURE SUBROUTINE CROTR4(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL32
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 4
#include "hrotr.F90"
  END SUBROUTINE CROTR4
  PURE SUBROUTINE CROTR8(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL32
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 8
#include "hrotr.F90"
  END SUBROUTINE CROTR8
END SUBROUTINE CROTR
