!>@brief \b ZROTRX premultiplies the rows (p,q) of G by W using an imperfect emulation of an accurate a*b+c*d operation.
PURE SUBROUTINE ZROTRX(M, N, G, LDG, P, Q, W, INFO)
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long_double
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
  IMPLICIT NONE
  INTEGER, PARAMETER :: K = REAL64, L = c_long_double
  INTEGER, INTENT(IN) :: M, N, LDG, P, Q
  COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
  COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
  INTEGER, INTENT(INOUT) :: INFO
  IF (MOD(N, 4) .EQ. 0) THEN
     CALL ZROTRX4(M, N, G, LDG, P, Q, W, INFO)
  ELSE IF (MOD(N, 2) .EQ. 0) THEN
     CALL ZROTRX2(M, N, G, LDG, P, Q, W, INFO)
  ELSE ! error
     INFO = -2
  END IF
CONTAINS
  PURE SUBROUTINE ZROTRX2(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long_double
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64, L = c_long_double
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 2
#undef HL
#define HL 1
#include "hrotra.F90"
  END SUBROUTINE ZROTRX2
  PURE SUBROUTINE ZROTRX4(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long_double
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64, L = c_long_double
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 4
#undef HL
#define HL 2
#include "hrotra.F90"
  END SUBROUTINE ZROTRX4
END SUBROUTINE ZROTRX
