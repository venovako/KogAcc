!>@brief \b CROTC postmultiplies the columns (p,q) of G by W.
PURE SUBROUTINE CROTC(M, N, G, LDG, P, Q, W, INFO)
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
  IMPLICIT NONE
#ifdef CR_MATH
  INTERFACE
     PURE FUNCTION CR_HYPOT(X, Y) BIND(C,NAME='cr_hypotf')
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_float
       REAL(KIND=c_float), INTENT(IN), VALUE :: X, Y
       REAL(KIND=c_float) :: CR_HYPOT
     END FUNCTION CR_HYPOT
  END INTERFACE
#else
#define CR_HYPOT HYPOT
#endif
  INTERFACE
     PURE FUNCTION CMUL(A, B)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
       IMPLICIT NONE
       COMPLEX(KIND=REAL32), INTENT(IN) :: A, B
       COMPLEX(KIND=REAL32) :: CMUL
     END FUNCTION CMUL
  END INTERFACE
#define MUL CMUL
  INTERFACE
     PURE FUNCTION CFMA(A, B, C)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
       IMPLICIT NONE
       COMPLEX(KIND=REAL32), INTENT(IN) :: A, B, C
       COMPLEX(KIND=REAL32) :: CFMA
     END FUNCTION CFMA
  END INTERFACE
#define FMA CFMA
  INTEGER, PARAMETER :: K = REAL32
  INTEGER, INTENT(IN) :: M, N, LDG, P, Q
  COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
  COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
  INTEGER, INTENT(INOUT) :: INFO
  IF (MOD(M, 8) .EQ. 0) THEN
     CALL CROTC8(M, N, G, LDG, P, Q, W, INFO)
  ELSE IF (MOD(M, 4) .EQ. 0) THEN
     CALL CROTC4(M, N, G, LDG, P, Q, W, INFO)
  ELSE IF (MOD(M, 2) .EQ. 0) THEN
     CALL CROTC2(M, N, G, LDG, P, Q, W, INFO)
  ELSE ! the general case
     CALL CROTC1(M, N, G, LDG, P, Q, W, INFO)
  END IF
CONTAINS
  PURE SUBROUTINE CROTC1(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL32
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 1
#include "hrotc.F90"
  END SUBROUTINE CROTC1
  PURE SUBROUTINE CROTC2(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL32
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 2
#include "hrotc.F90"
  END SUBROUTINE CROTC2
  PURE SUBROUTINE CROTC4(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL32
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 4
#include "hrotc.F90"
  END SUBROUTINE CROTC4
  PURE SUBROUTINE CROTC8(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL32
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 8
#include "hrotc.F90"
  END SUBROUTINE CROTC8
END SUBROUTINE CROTC
