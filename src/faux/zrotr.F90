!>@brief \b ZROTR premultiplies the rows (p,q) of G by W.
PURE SUBROUTINE ZROTR(M, N, G, LDG, P, Q, W, INFO)
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
  IMPLICIT NONE
#ifdef CR_MATH
  INTERFACE
     PURE FUNCTION CR_HYPOT(X, Y) BIND(C,NAME='cr_hypot')
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_double
       REAL(KIND=c_double), INTENT(IN), VALUE :: X, Y
       REAL(KIND=c_double) :: CR_HYPOT
     END FUNCTION CR_HYPOT
  END INTERFACE
#else
#define CR_HYPOT HYPOT
#endif
  INTERFACE
     PURE FUNCTION ZMUL(A, B)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       COMPLEX(KIND=REAL64), INTENT(IN) :: A, B
       COMPLEX(KIND=REAL64) :: ZMUL
     END FUNCTION ZMUL
  END INTERFACE
#define MUL ZMUL
  INTERFACE
     PURE FUNCTION ZFMA(A, B, C)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       COMPLEX(KIND=REAL64), INTENT(IN) :: A, B, C
       COMPLEX(KIND=REAL64) :: ZFMA
     END FUNCTION ZFMA
  END INTERFACE
#define FMA ZFMA
  INTEGER, PARAMETER :: K = REAL64
  INTEGER, INTENT(IN) :: M, N, LDG, P, Q
  COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
  COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
  INTEGER, INTENT(INOUT) :: INFO
  IF (MOD(N, 4) .EQ. 0) THEN
     CALL ZROTR4(M, N, G, LDG, P, Q, W, INFO)
  ELSE IF (MOD(N, 2) .EQ. 0) THEN
     CALL ZROTR2(M, N, G, LDG, P, Q, W, INFO)
  ELSE ! the general case
     CALL ZROTR1(M, N, G, LDG, P, Q, W, INFO)
  END IF
CONTAINS
  PURE SUBROUTINE ZROTR1(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 1
#include "hrotr.F90"
  END SUBROUTINE ZROTR1
  PURE SUBROUTINE ZROTR2(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 2
#include "hrotr.F90"
  END SUBROUTINE ZROTR2
  PURE SUBROUTINE ZROTR4(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 4
#include "hrotr.F90"
  END SUBROUTINE ZROTR4
END SUBROUTINE ZROTR
