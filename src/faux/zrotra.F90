!>@brief \b ZROTRA premultiplies the rows (p,q) of G by W using an imperfect emulation of an accurate a*b+c*d operation.
PURE SUBROUTINE ZROTRA(M, N, G, LDG, P, Q, W, INFO)
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64, REAL128
  IMPLICIT NONE
  INTEGER, PARAMETER :: K = REAL64, L = REAL128
  INTEGER, INTENT(IN) :: M, N, LDG, P, Q
  COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
  COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
  INTEGER, INTENT(INOUT) :: INFO
  IF (MOD(N, 4) .EQ. 0) THEN
     CALL ZROTRA4(M, N, G, LDG, P, Q, W, INFO)
  ELSE IF (MOD(N, 2) .EQ. 0) THEN
     CALL ZROTRA2(M, N, G, LDG, P, Q, W, INFO)
  ELSE ! error
     INFO = -2
  END IF
CONTAINS
  PURE SUBROUTINE ZROTRA2(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64, REAL128
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64, L = REAL128
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 2
#undef HL
#define HL 1
#include "hrotra.F90"
  END SUBROUTINE ZROTRA2
  PURE SUBROUTINE ZROTRA4(M, N, G, LDG, P, Q, W, INFO)
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64, REAL128
    IMPLICIT NONE
    INTEGER, PARAMETER :: K = REAL64, L = REAL128
    INTEGER, INTENT(IN) :: M, N, LDG, P, Q
    COMPLEX(KIND=K), INTENT(INOUT) :: G(LDG,N)
    COMPLEX(KIND=K), INTENT(IN) :: W(2,2)
    INTEGER, INTENT(INOUT) :: INFO
#undef VL
#define VL 4
#undef HL
#define HL 2
#include "hrotra.F90"
  END SUBROUTINE ZROTRA4
END SUBROUTINE ZROTRA
