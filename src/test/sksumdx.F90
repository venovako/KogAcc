!>@brief \b SKSUMDX tests the SKSUMD routine.
PROGRAM SKSUMDX
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64, REAL32, REAL128, ERROR_UNIT, OUTPUT_UNIT
  !$ USE OMP_LIB
  IMPLICIT NONE

  INTERFACE
     PURE SUBROUTINE NB2M(N, B, M, INFO)
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, B
       INTEGER, INTENT(OUT) :: M, INFO
     END SUBROUTINE NB2M
  END INTERFACE
  INTERFACE
     SUBROUTINE SBRDG(M, N, G, LDG, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: M, N, LDG
       REAL(KIND=REAL32), INTENT(OUT) :: G(LDG,M)
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE SBRDG
  END INTERFACE
  INTERFACE
     SUBROUTINE SRDINP(BN, M, N, G, LDG, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32
       IMPLICIT NONE
       CHARACTER(LEN=*), INTENT(IN) :: BN
       INTEGER, INTENT(IN) :: M, N, LDG
       REAL(KIND=REAL32), INTENT(OUT) :: G(LDG,M)
       INTEGER, INTENT(OUT) :: INFO
     END SUBROUTINE SRDINP
  END INTERFACE
  INTERFACE
     SUBROUTINE SKSUMD(JOB, N, G, LDG, U, LDU, V, LDV, SV, W, O, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32, REAL128
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: JOB, N, LDG, LDU, LDV
       REAL(KIND=REAL32), INTENT(INOUT) :: G(LDG,N), U(LDU,N), V(LDV,N)
       REAL(KIND=REAL128), INTENT(OUT), TARGET :: SV(N)
       REAL(KIND=REAL32), INTENT(INOUT), TARGET :: W(*)
       INTEGER, INTENT(INOUT), TARGET :: O(2,*)
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE SKSUMD
  END INTERFACE
  INTERFACE
     SUBROUTINE SWROUT(BN, J, N, U, LDU, V, LDV, S, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL32, REAL128
       IMPLICIT NONE
       CHARACTER(LEN=*), INTENT(IN) :: BN
       INTEGER, INTENT(IN) :: J, N, LDU, LDV
       REAL(KIND=REAL32), INTENT(IN) :: U(LDU,N), V(LDV,N)
       REAL(KIND=REAL128), INTENT(IN) :: S(N)
       INTEGER, INTENT(OUT) :: INFO
     END SUBROUTINE SWROUT
  END INTERFACE

  INTEGER, PARAMETER :: K = REAL32, CLAL = 256
  CHARACTER(LEN=CLAL) :: BN
  INTEGER(KIND=INT64) :: C0, C1, CR
  REAL(KIND=REAL128) :: T
  INTEGER :: JOB, M, N, LDG, LDU, LDV, INFO, I, J, L
  REAL(KIND=K), ALLOCATABLE, TARGET :: G(:,:)
  !DIR$ ATTRIBUTES ALIGN: 64:: G
  REAL(KIND=K), ALLOCATABLE :: U(:,:)
  !DIR$ ATTRIBUTES ALIGN: 64:: U
  REAL(KIND=K), ALLOCATABLE :: V(:,:)
  !DIR$ ATTRIBUTES ALIGN: 64:: V
  REAL(KIND=K), ALLOCATABLE, TARGET :: W(:)
  !DIR$ ATTRIBUTES ALIGN: 64:: W
  REAL(KIND=REAL128), ALLOCATABLE, TARGET :: SV(:)
  !DIR$ ATTRIBUTES ALIGN: 64:: SV
  INTEGER, ALLOCATABLE, TARGET :: O(:,:)
  !DIR$ ATTRIBUTES ALIGN: 64:: O

  I = COMMAND_ARGUMENT_COUNT()
  IF (I .NE. 2) THEN
     CALL GET_COMMAND_ARGUMENT(0, BN)
     WRITE (ERROR_UNIT,*) TRIM(BN), ' N BN'
     ERROR STOP 'INVALID COMMAND LINE'
  END IF
  CALL GET_COMMAND_ARGUMENT(1, BN, I, INFO)
  IF (INFO .NE. 0) ERROR STOP 'N'
  READ (BN,*) N
  CALL GET_COMMAND_ARGUMENT(2, BN, I, INFO)
  IF (INFO .NE. 0) ERROR STOP 'BN'

  L = 0
  !$ L = 1
  IF (N .EQ. 0) ERROR STOP 'N'
  IF (N .LT. 0) THEN
     N = -N
     I = -1
  ELSE ! the default mode is "slow"
     I = 0
  END IF
  M = N + MOD(N, 2)
#ifdef __INTEL_COMPILER
  LDV = 64
  LDU = LDV / INT(SIZEOF(0.0_K))
  LDG = MOD(M, LDU)
  IF (LDG .NE. 0) M = M + (LDU - LDG)
#endif
  LDG = M
  LDU = M
  LDV = M

  ALLOCATE(U(LDU,M))
  IF (M .GT. N) THEN
     INFO = L
     CALL SBRDG(M, N, U, LDU, INFO)
     IF (INFO .NE. 0) ERROR STOP 'SBRDG(U)'
  END IF

  ALLOCATE(V(LDV,M))
  IF (M .GT. N) THEN
     INFO = L
     CALL SBRDG(M, N, V, LDV, INFO)
     IF (INFO .NE. 0) ERROR STOP 'SBRDG(V)'
  END IF

  ALLOCATE(G(LDG,M))
  IF (M .GT. N) THEN
     INFO = L
     CALL SBRDG(M, N, G, LDG, INFO)
     IF (INFO .NE. 0) ERROR STOP 'SBRDG(G)'
  END IF

  INFO = L
  CALL SRDINP(BN, M, N, G, LDG, INFO)
  IF (INFO .NE. 0) ERROR STOP 'SRDINP'

  ALLOCATE(SV(M))
  ALLOCATE(W(MAX((M-1),3)*M))
  ! if, e.g., ||G||_F is known to be numerically finite and reasonably below HUGE,
  ! the dynamic scaling can be turned off for speed
  W(1) = REAL(I, K)
  W(2) = 0.0_K
  W(3) = 0.0_K

  ALLOCATE(O(2,M*(M/2)))
  JOB = 1
  DO I = 1, M-1
     DO J = I+1, M
        O(1,JOB) = I
        O(2,JOB) = J
        JOB = JOB + 1
     END DO
  END DO
  J = 3
  JOB = 123
  INFO = -HUGE(INFO)
  INFO = INFO - 1
  !$ IF (L .NE. 0) INFO = -(INFO + 1)
  CALL SYSTEM_CLOCK(C0)
  CALL SKSUMD(JOB, M, G, LDG, U, LDU, V, LDV, SV, W, O, INFO)
  CALL SYSTEM_CLOCK(C1, CR)
  T = REAL(CR, REAL128)
  T = REAL(C1 - C0, REAL128) / T
  WRITE (OUTPUT_UNIT,'(A,F15.6,A,I11,A)',ADVANCE='NO') 'SKSUMD took ', T, ' s with ', INFO, ' steps and W=('
  WRITE (OUTPUT_UNIT,9) W(1), ',', W(2), ',', W(3), ')'
  FLUSH(OUTPUT_UNIT)
  IF (INFO .LT. 0) THEN
     WRITE (ERROR_UNIT,*) 'ERROR in SKSUMD'
  ELSE IF (INFO .EQ. HUGE(INFO)) THEN
     WRITE (ERROR_UNIT,*) 'NO CONVERGENCE'
  ELSE ! all OK
     WRITE (ERROR_UNIT,*) 'output basename: ', TRIM(BN)
  END IF

  DEALLOCATE(O)
  DEALLOCATE(W)
  DEALLOCATE(G)

  INFO = L
  CALL SWROUT(BN, J, N, U, LDU, V, LDV, SV, INFO)
  IF (INFO .NE. 0) ERROR STOP 'SWROUT'

  DEALLOCATE(SV)
  DEALLOCATE(V)
  DEALLOCATE(U)

9 FORMAT(3(ES16.9E2,A))
END PROGRAM SKSUMDX
