!>@brief \b DMKBPQX tests the DMKBPQ routine.
PROGRAM DMKBPQX
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64, REAL64, REAL128, ERROR_UNIT, OUTPUT_UNIT
  IMPLICIT NONE
#ifndef __GFORTRAN__
  INTERFACE
     PURE SUBROUTINE NB2M(N, B, M, INFO)
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, B
       INTEGER, INTENT(OUT) :: M, INFO
     END SUBROUTINE NB2M
  END INTERFACE
  INTERFACE
     SUBROUTINE BFOPEN(FN, ACT, U, INFO)
       IMPLICIT NONE
       CHARACTER(LEN=*), INTENT(IN) :: FN
       CHARACTER(LEN=2), INTENT(IN) :: ACT
       INTEGER, INTENT(OUT) :: U, INFO
     END SUBROUTINE BFOPEN
  END INTERFACE
  INTERFACE
     SUBROUTINE DBRD2(U, M, N, G, LDG, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: U, M, N, LDG
       REAL(KIND=REAL64), INTENT(OUT) :: G(LDG,N)
       INTEGER, INTENT(OUT) :: INFO
     END SUBROUTINE DBRD2
  END INTERFACE
  INTERFACE
     SUBROUTINE DBRDG(M, N, G, LDG, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: M, N, LDG
       REAL(KIND=REAL64), INTENT(OUT) :: G(LDG,M)
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DBRDG
  END INTERFACE
  INTERFACE
     SUBROUTINE DMKBPQ(N, G, LDG, B, W, D, O, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64, REAL128
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDG, B
       REAL(KIND=REAL64), INTENT(IN) :: G(LDG,N)
       REAL(KIND=REAL64), INTENT(OUT) :: W(N/B,N/B)
       REAL(KIND=REAL128), INTENT(OUT) :: D(*)
       INTEGER, INTENT(INOUT) :: O(2,*), INFO
     END SUBROUTINE DMKBPQ
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE QDEC(E, P, Q) BIND(C,NAME='pvn_djs_qdec_')
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL128
       REAL(KIND=REAL128), INTENT(IN) :: E
       INTEGER, INTENT(OUT) :: P, Q
     END SUBROUTINE QDEC
  END INTERFACE
#endif
  INTEGER, PARAMETER :: K = REAL64, CLAL = 256
  CHARACTER(LEN=CLAL) :: BN
  INTEGER(KIND=INT64) :: C0, C1, CR
  REAL(KIND=REAL128) :: T
  INTEGER :: B, I, J, L, M, N, LDG, INFO
  REAL(KIND=K), ALLOCATABLE :: G(:,:)
  !DIR$ ATTRIBUTES ALIGN: 64:: G
  REAL(KIND=K), ALLOCATABLE :: W(:,:)
  !DIR$ ATTRIBUTES ALIGN: 64:: W
  REAL(KIND=REAL128), ALLOCATABLE :: D(:)
  !DIR$ ATTRIBUTES ALIGN: 64:: D
  INTEGER, ALLOCATABLE :: O(:,:)
  !DIR$ ATTRIBUTES ALIGN: 64:: O
#ifdef __GFORTRAN__
  EXTERNAL :: NB2M, BFOPEN, DBRD2, DBRDG, DMKBPQ, PVN_DJS_QDEC
#define QDEC PVN_DJS_QDEC
#endif
  I = COMMAND_ARGUMENT_COUNT()
  IF (I .NE. 3) THEN
     CALL GET_COMMAND_ARGUMENT(0, BN)
     WRITE (ERROR_UNIT,*) TRIM(BN), ' N B BN'
     ERROR STOP 'INVALID COMMAND LINE'
  END IF
  CALL GET_COMMAND_ARGUMENT(1, BN, I, INFO)
  IF (INFO .NE. 0) ERROR STOP 'N'
  READ (BN,*) N
  CALL GET_COMMAND_ARGUMENT(2, BN, I, INFO)
  IF (INFO .NE. 0) ERROR STOP 'B'
  READ (BN,*) B
  CALL GET_COMMAND_ARGUMENT(3, BN, I, INFO)
  IF (INFO .NE. 0) ERROR STOP 'BN'

  IF (N .LE. 0) ERROR STOP 'N'
  CALL NB2M(N, B, I, INFO)
  IF (INFO .NE. 0) ERROR STOP 'B'
  LDG = I

  ALLOCATE(G(LDG,I))
  IF (LDG .GT. N) THEN
     INFO = 0
     !$ INFO = 1
     CALL DBRDG(I, N, G, LDG, INFO)
     IF (INFO .NE. 0) ERROR STOP 'DBRDG(G)'
  ELSE
     INFO = 0
  END IF

  CALL BFOPEN(TRIM(BN)//'.G', 'RO', J, INFO)
  IF (INFO .NE. 0) ERROR STOP 'BFOPEN'
  CALL DBRD2(J, N, N, G, LDG, INFO)
  IF (INFO .NE. 0) ERROR STOP 'DBRD2'
  CLOSE(J, IOSTAT=INFO)
  IF (INFO .NE. 0) ERROR STOP 'CLOSE'

  N = I
  M = N / B
  IF (MOD(M, 2) .EQ. 0) THEN
     L = (M / 2) * (M - 1)
  ELSE ! M odd
     L = M * ((M - 1) / 2)
  END IF
  J = L + (M / 2)

  ALLOCATE(W(M,M))
  ALLOCATE(D(L+1))
  ALLOCATE(O(2,J))

  INFO = 1
  DO I = 1, M-1
     DO J = I+1, M
        O(1,INFO) = I
        O(2,INFO) = J
        INFO = INFO + 1
     END DO
  END DO

  CALL SYSTEM_CLOCK(C0)
  INFO = 0
  !$ INFO = 1
  CALL DMKBPQ(N, G, LDG, B, W, D, O, INFO)
  CALL SYSTEM_CLOCK(C1, CR)
  T = REAL(CR, REAL128)
  T = REAL(C1 - C0, REAL128) / T
  WRITE (OUTPUT_UNIT,'(A,F15.6,A)',ADVANCE='NO') 'DMKBPQ took ', T, ' s'
  WRITE (OUTPUT_UNIT,'(I11,A)') INFO, ' steps generated'
  FLUSH(OUTPUT_UNIT)
  DO I = 1, INFO
     J = L + I
     WRITE (OUTPUT_UNIT,'(A,I11,A,I11,A)') '(', O(1,J), ',', O(2,J), ')'
  END DO
  FLUSH(OUTPUT_UNIT)
  DO N = 1, L
     CALL QDEC(D(N), I, J)
     WRITE (OUTPUT_UNIT,'(A,I11,A,I11,A,ES25.17E3)') 'D(', I, ',', J, ')=', D(N)
  END DO
  FLUSH(OUTPUT_UNIT)
  DO J = 1, M
     DO I = 1, M
        WRITE (OUTPUT_UNIT,'(ES25.17E3)',ADVANCE='NO') W(I,J)
     END DO
     WRITE (OUTPUT_UNIT,*)
     FLUSH(OUTPUT_UNIT)
  END DO

  DEALLOCATE(O)
  DEALLOCATE(D)
  DEALLOCATE(W)
  DEALLOCATE(G)
END PROGRAM DMKBPQX
